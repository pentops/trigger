// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             (unknown)
// source: o5/trigger/v1/service/trigger.p.j5s.proto

package trigger_spb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	TriggerQueryService_TriggerGet_FullMethodName    = "/o5.trigger.v1.service.TriggerQueryService/TriggerGet"
	TriggerQueryService_TriggerList_FullMethodName   = "/o5.trigger.v1.service.TriggerQueryService/TriggerList"
	TriggerQueryService_TriggerEvents_FullMethodName = "/o5.trigger.v1.service.TriggerQueryService/TriggerEvents"
)

// TriggerQueryServiceClient is the client API for TriggerQueryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TriggerQueryServiceClient interface {
	TriggerGet(ctx context.Context, in *TriggerGetRequest, opts ...grpc.CallOption) (*TriggerGetResponse, error)
	TriggerList(ctx context.Context, in *TriggerListRequest, opts ...grpc.CallOption) (*TriggerListResponse, error)
	TriggerEvents(ctx context.Context, in *TriggerEventsRequest, opts ...grpc.CallOption) (*TriggerEventsResponse, error)
}

type triggerQueryServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTriggerQueryServiceClient(cc grpc.ClientConnInterface) TriggerQueryServiceClient {
	return &triggerQueryServiceClient{cc}
}

func (c *triggerQueryServiceClient) TriggerGet(ctx context.Context, in *TriggerGetRequest, opts ...grpc.CallOption) (*TriggerGetResponse, error) {
	out := new(TriggerGetResponse)
	err := c.cc.Invoke(ctx, TriggerQueryService_TriggerGet_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *triggerQueryServiceClient) TriggerList(ctx context.Context, in *TriggerListRequest, opts ...grpc.CallOption) (*TriggerListResponse, error) {
	out := new(TriggerListResponse)
	err := c.cc.Invoke(ctx, TriggerQueryService_TriggerList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *triggerQueryServiceClient) TriggerEvents(ctx context.Context, in *TriggerEventsRequest, opts ...grpc.CallOption) (*TriggerEventsResponse, error) {
	out := new(TriggerEventsResponse)
	err := c.cc.Invoke(ctx, TriggerQueryService_TriggerEvents_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TriggerQueryServiceServer is the server API for TriggerQueryService service.
// All implementations must embed UnimplementedTriggerQueryServiceServer
// for forward compatibility
type TriggerQueryServiceServer interface {
	TriggerGet(context.Context, *TriggerGetRequest) (*TriggerGetResponse, error)
	TriggerList(context.Context, *TriggerListRequest) (*TriggerListResponse, error)
	TriggerEvents(context.Context, *TriggerEventsRequest) (*TriggerEventsResponse, error)
	mustEmbedUnimplementedTriggerQueryServiceServer()
}

// UnimplementedTriggerQueryServiceServer must be embedded to have forward compatible implementations.
type UnimplementedTriggerQueryServiceServer struct {
}

func (UnimplementedTriggerQueryServiceServer) TriggerGet(context.Context, *TriggerGetRequest) (*TriggerGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TriggerGet not implemented")
}
func (UnimplementedTriggerQueryServiceServer) TriggerList(context.Context, *TriggerListRequest) (*TriggerListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TriggerList not implemented")
}
func (UnimplementedTriggerQueryServiceServer) TriggerEvents(context.Context, *TriggerEventsRequest) (*TriggerEventsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TriggerEvents not implemented")
}
func (UnimplementedTriggerQueryServiceServer) mustEmbedUnimplementedTriggerQueryServiceServer() {}

// UnsafeTriggerQueryServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TriggerQueryServiceServer will
// result in compilation errors.
type UnsafeTriggerQueryServiceServer interface {
	mustEmbedUnimplementedTriggerQueryServiceServer()
}

func RegisterTriggerQueryServiceServer(s grpc.ServiceRegistrar, srv TriggerQueryServiceServer) {
	s.RegisterService(&TriggerQueryService_ServiceDesc, srv)
}

func _TriggerQueryService_TriggerGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TriggerGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TriggerQueryServiceServer).TriggerGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TriggerQueryService_TriggerGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TriggerQueryServiceServer).TriggerGet(ctx, req.(*TriggerGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TriggerQueryService_TriggerList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TriggerListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TriggerQueryServiceServer).TriggerList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TriggerQueryService_TriggerList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TriggerQueryServiceServer).TriggerList(ctx, req.(*TriggerListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TriggerQueryService_TriggerEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TriggerEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TriggerQueryServiceServer).TriggerEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TriggerQueryService_TriggerEvents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TriggerQueryServiceServer).TriggerEvents(ctx, req.(*TriggerEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TriggerQueryService_ServiceDesc is the grpc.ServiceDesc for TriggerQueryService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TriggerQueryService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "o5.trigger.v1.service.TriggerQueryService",
	HandlerType: (*TriggerQueryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "TriggerGet",
			Handler:    _TriggerQueryService_TriggerGet_Handler,
		},
		{
			MethodName: "TriggerList",
			Handler:    _TriggerQueryService_TriggerList_Handler,
		},
		{
			MethodName: "TriggerEvents",
			Handler:    _TriggerQueryService_TriggerEvents_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "o5/trigger/v1/service/trigger.p.j5s.proto",
}

const (
	TriggerCommandService_PauseTrigger_FullMethodName    = "/o5.trigger.v1.service.TriggerCommandService/PauseTrigger"
	TriggerCommandService_ResumeTrigger_FullMethodName   = "/o5.trigger.v1.service.TriggerCommandService/ResumeTrigger"
	TriggerCommandService_ManuallyTrigger_FullMethodName = "/o5.trigger.v1.service.TriggerCommandService/ManuallyTrigger"
)

// TriggerCommandServiceClient is the client API for TriggerCommandService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TriggerCommandServiceClient interface {
	PauseTrigger(ctx context.Context, in *PauseTriggerRequest, opts ...grpc.CallOption) (*PauseTriggerResponse, error)
	ResumeTrigger(ctx context.Context, in *ResumeTriggerRequest, opts ...grpc.CallOption) (*ResumeTriggerResponse, error)
	ManuallyTrigger(ctx context.Context, in *ManuallyTriggerRequest, opts ...grpc.CallOption) (*ManuallyTriggerResponse, error)
}

type triggerCommandServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTriggerCommandServiceClient(cc grpc.ClientConnInterface) TriggerCommandServiceClient {
	return &triggerCommandServiceClient{cc}
}

func (c *triggerCommandServiceClient) PauseTrigger(ctx context.Context, in *PauseTriggerRequest, opts ...grpc.CallOption) (*PauseTriggerResponse, error) {
	out := new(PauseTriggerResponse)
	err := c.cc.Invoke(ctx, TriggerCommandService_PauseTrigger_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *triggerCommandServiceClient) ResumeTrigger(ctx context.Context, in *ResumeTriggerRequest, opts ...grpc.CallOption) (*ResumeTriggerResponse, error) {
	out := new(ResumeTriggerResponse)
	err := c.cc.Invoke(ctx, TriggerCommandService_ResumeTrigger_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *triggerCommandServiceClient) ManuallyTrigger(ctx context.Context, in *ManuallyTriggerRequest, opts ...grpc.CallOption) (*ManuallyTriggerResponse, error) {
	out := new(ManuallyTriggerResponse)
	err := c.cc.Invoke(ctx, TriggerCommandService_ManuallyTrigger_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TriggerCommandServiceServer is the server API for TriggerCommandService service.
// All implementations must embed UnimplementedTriggerCommandServiceServer
// for forward compatibility
type TriggerCommandServiceServer interface {
	PauseTrigger(context.Context, *PauseTriggerRequest) (*PauseTriggerResponse, error)
	ResumeTrigger(context.Context, *ResumeTriggerRequest) (*ResumeTriggerResponse, error)
	ManuallyTrigger(context.Context, *ManuallyTriggerRequest) (*ManuallyTriggerResponse, error)
	mustEmbedUnimplementedTriggerCommandServiceServer()
}

// UnimplementedTriggerCommandServiceServer must be embedded to have forward compatible implementations.
type UnimplementedTriggerCommandServiceServer struct {
}

func (UnimplementedTriggerCommandServiceServer) PauseTrigger(context.Context, *PauseTriggerRequest) (*PauseTriggerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PauseTrigger not implemented")
}
func (UnimplementedTriggerCommandServiceServer) ResumeTrigger(context.Context, *ResumeTriggerRequest) (*ResumeTriggerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResumeTrigger not implemented")
}
func (UnimplementedTriggerCommandServiceServer) ManuallyTrigger(context.Context, *ManuallyTriggerRequest) (*ManuallyTriggerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ManuallyTrigger not implemented")
}
func (UnimplementedTriggerCommandServiceServer) mustEmbedUnimplementedTriggerCommandServiceServer() {}

// UnsafeTriggerCommandServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TriggerCommandServiceServer will
// result in compilation errors.
type UnsafeTriggerCommandServiceServer interface {
	mustEmbedUnimplementedTriggerCommandServiceServer()
}

func RegisterTriggerCommandServiceServer(s grpc.ServiceRegistrar, srv TriggerCommandServiceServer) {
	s.RegisterService(&TriggerCommandService_ServiceDesc, srv)
}

func _TriggerCommandService_PauseTrigger_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PauseTriggerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TriggerCommandServiceServer).PauseTrigger(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TriggerCommandService_PauseTrigger_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TriggerCommandServiceServer).PauseTrigger(ctx, req.(*PauseTriggerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TriggerCommandService_ResumeTrigger_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResumeTriggerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TriggerCommandServiceServer).ResumeTrigger(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TriggerCommandService_ResumeTrigger_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TriggerCommandServiceServer).ResumeTrigger(ctx, req.(*ResumeTriggerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TriggerCommandService_ManuallyTrigger_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ManuallyTriggerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TriggerCommandServiceServer).ManuallyTrigger(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TriggerCommandService_ManuallyTrigger_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TriggerCommandServiceServer).ManuallyTrigger(ctx, req.(*ManuallyTriggerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TriggerCommandService_ServiceDesc is the grpc.ServiceDesc for TriggerCommandService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TriggerCommandService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "o5.trigger.v1.service.TriggerCommandService",
	HandlerType: (*TriggerCommandServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PauseTrigger",
			Handler:    _TriggerCommandService_PauseTrigger_Handler,
		},
		{
			MethodName: "ResumeTrigger",
			Handler:    _TriggerCommandService_ResumeTrigger_Handler,
		},
		{
			MethodName: "ManuallyTrigger",
			Handler:    _TriggerCommandService_ManuallyTrigger_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "o5/trigger/v1/service/trigger.p.j5s.proto",
}
