// Code generated by protoc-gen-go-sugar. DO NOT EDIT.

package trigger_pb

import (
	driver "database/sql/driver"
	fmt "fmt"
	proto "google.golang.org/protobuf/proto"
)

// TriggerEventType is a oneof wrapper
type TriggerEventTypeKey string

const (
	TriggerEvent_Created           TriggerEventTypeKey = "created"
	TriggerEvent_Updated           TriggerEventTypeKey = "updated"
	TriggerEvent_Paused            TriggerEventTypeKey = "paused"
	TriggerEvent_Activated         TriggerEventTypeKey = "activated"
	TriggerEvent_ManuallyTriggered TriggerEventTypeKey = "manuallyTriggered"
	TriggerEvent_Triggered         TriggerEventTypeKey = "triggered"
	TriggerEvent_Archived          TriggerEventTypeKey = "archived"
)

func (x *TriggerEventType) TypeKey() (TriggerEventTypeKey, bool) {
	switch x.Type.(type) {
	case *TriggerEventType_Created_:
		return TriggerEvent_Created, true
	case *TriggerEventType_Updated_:
		return TriggerEvent_Updated, true
	case *TriggerEventType_Paused_:
		return TriggerEvent_Paused, true
	case *TriggerEventType_Activated_:
		return TriggerEvent_Activated, true
	case *TriggerEventType_ManuallyTriggered_:
		return TriggerEvent_ManuallyTriggered, true
	case *TriggerEventType_Triggered_:
		return TriggerEvent_Triggered, true
	case *TriggerEventType_Archived_:
		return TriggerEvent_Archived, true
	default:
		return "", false
	}
}

type IsTriggerEventTypeWrappedType interface {
	TypeKey() TriggerEventTypeKey
	proto.Message
}

func (x *TriggerEventType) Set(val IsTriggerEventTypeWrappedType) {
	switch v := val.(type) {
	case *TriggerEventType_Created:
		x.Type = &TriggerEventType_Created_{Created: v}
	case *TriggerEventType_Updated:
		x.Type = &TriggerEventType_Updated_{Updated: v}
	case *TriggerEventType_Paused:
		x.Type = &TriggerEventType_Paused_{Paused: v}
	case *TriggerEventType_Activated:
		x.Type = &TriggerEventType_Activated_{Activated: v}
	case *TriggerEventType_ManuallyTriggered:
		x.Type = &TriggerEventType_ManuallyTriggered_{ManuallyTriggered: v}
	case *TriggerEventType_Triggered:
		x.Type = &TriggerEventType_Triggered_{Triggered: v}
	case *TriggerEventType_Archived:
		x.Type = &TriggerEventType_Archived_{Archived: v}
	}
}
func (x *TriggerEventType) Get() IsTriggerEventTypeWrappedType {
	switch v := x.Type.(type) {
	case *TriggerEventType_Created_:
		return v.Created
	case *TriggerEventType_Updated_:
		return v.Updated
	case *TriggerEventType_Paused_:
		return v.Paused
	case *TriggerEventType_Activated_:
		return v.Activated
	case *TriggerEventType_ManuallyTriggered_:
		return v.ManuallyTriggered
	case *TriggerEventType_Triggered_:
		return v.Triggered
	case *TriggerEventType_Archived_:
		return v.Archived
	default:
		return nil
	}
}
func (x *TriggerEventType_Created) TypeKey() TriggerEventTypeKey {
	return TriggerEvent_Created
}
func (x *TriggerEventType_Updated) TypeKey() TriggerEventTypeKey {
	return TriggerEvent_Updated
}
func (x *TriggerEventType_Paused) TypeKey() TriggerEventTypeKey {
	return TriggerEvent_Paused
}
func (x *TriggerEventType_Activated) TypeKey() TriggerEventTypeKey {
	return TriggerEvent_Activated
}
func (x *TriggerEventType_ManuallyTriggered) TypeKey() TriggerEventTypeKey {
	return TriggerEvent_ManuallyTriggered
}
func (x *TriggerEventType_Triggered) TypeKey() TriggerEventTypeKey {
	return TriggerEvent_Triggered
}
func (x *TriggerEventType_Archived) TypeKey() TriggerEventTypeKey {
	return TriggerEvent_Archived
}

type IsTriggerEventType_Type = isTriggerEventType_Type

// ActionType is a oneof wrapper
type ActionTypeKey string

const (
	Action_Create  ActionTypeKey = "create"
	Action_Update  ActionTypeKey = "update"
	Action_Archive ActionTypeKey = "archive"
)

func (x *ActionType) TypeKey() (ActionTypeKey, bool) {
	switch x.Type.(type) {
	case *ActionType_Create_:
		return Action_Create, true
	case *ActionType_Update_:
		return Action_Update, true
	case *ActionType_Archive_:
		return Action_Archive, true
	default:
		return "", false
	}
}

type IsActionTypeWrappedType interface {
	TypeKey() ActionTypeKey
	proto.Message
}

func (x *ActionType) Set(val IsActionTypeWrappedType) {
	switch v := val.(type) {
	case *ActionType_Create:
		x.Type = &ActionType_Create_{Create: v}
	case *ActionType_Update:
		x.Type = &ActionType_Update_{Update: v}
	case *ActionType_Archive:
		x.Type = &ActionType_Archive_{Archive: v}
	}
}
func (x *ActionType) Get() IsActionTypeWrappedType {
	switch v := x.Type.(type) {
	case *ActionType_Create_:
		return v.Create
	case *ActionType_Update_:
		return v.Update
	case *ActionType_Archive_:
		return v.Archive
	default:
		return nil
	}
}
func (x *ActionType_Create) TypeKey() ActionTypeKey {
	return Action_Create
}
func (x *ActionType_Update) TypeKey() ActionTypeKey {
	return Action_Update
}
func (x *ActionType_Archive) TypeKey() ActionTypeKey {
	return Action_Archive
}

type IsActionType_Type = isActionType_Type

// TriggerStatus
const (
	TriggerStatus_UNSPECIFIED TriggerStatus = 0
	TriggerStatus_ACTIVE      TriggerStatus = 1
	TriggerStatus_PAUSED      TriggerStatus = 2
	TriggerStatus_ARCHIVED    TriggerStatus = 3
)

var (
	TriggerStatus_name_short = map[int32]string{
		0: "UNSPECIFIED",
		1: "ACTIVE",
		2: "PAUSED",
		3: "ARCHIVED",
	}
	TriggerStatus_value_short = map[string]int32{
		"UNSPECIFIED": 0,
		"ACTIVE":      1,
		"PAUSED":      2,
		"ARCHIVED":    3,
	}
	TriggerStatus_value_either = map[string]int32{
		"UNSPECIFIED":                0,
		"TRIGGER_STATUS_UNSPECIFIED": 0,
		"ACTIVE":                     1,
		"TRIGGER_STATUS_ACTIVE":      1,
		"PAUSED":                     2,
		"TRIGGER_STATUS_PAUSED":      2,
		"ARCHIVED":                   3,
		"TRIGGER_STATUS_ARCHIVED":    3,
	}
)

// ShortString returns the un-prefixed string representation of the enum value
func (x TriggerStatus) ShortString() string {
	return TriggerStatus_name_short[int32(x)]
}
func (x TriggerStatus) Value() (driver.Value, error) {
	return []uint8(x.ShortString()), nil
}
func (x *TriggerStatus) Scan(value interface{}) error {
	var strVal string
	switch vt := value.(type) {
	case []uint8:
		strVal = string(vt)
	case string:
		strVal = vt
	default:
		return fmt.Errorf("invalid type %T", value)
	}
	val := TriggerStatus_value_either[strVal]
	*x = TriggerStatus(val)
	return nil
}
