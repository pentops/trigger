// Code generated by protoc-gen-go-j5. DO NOT EDIT.

package trigger_pb

import (
	context "context"
	fmt "fmt"
	psm_j5pb "github.com/pentops/j5/gen/j5/state/v1/psm_j5pb"
	psm "github.com/pentops/j5/lib/psm"
	sqrlx "github.com/pentops/sqrlx.go/sqrlx"
)

// PSM TriggerPSM

type TriggerPSM = psm.StateMachine[
	*TriggerKeys,    // implements psm.IKeyset
	*TriggerState,   // implements psm.IState
	TriggerStatus,   // implements psm.IStatusEnum
	*TriggerData,    // implements psm.IStateData
	*TriggerEvent,   // implements psm.IEvent
	TriggerPSMEvent, // implements psm.IInnerEvent
]

type TriggerPSMDB = psm.DBStateMachine[
	*TriggerKeys,    // implements psm.IKeyset
	*TriggerState,   // implements psm.IState
	TriggerStatus,   // implements psm.IStatusEnum
	*TriggerData,    // implements psm.IStateData
	*TriggerEvent,   // implements psm.IEvent
	TriggerPSMEvent, // implements psm.IInnerEvent
]

type TriggerPSMEventSpec = psm.EventSpec[
	*TriggerKeys,    // implements psm.IKeyset
	*TriggerState,   // implements psm.IState
	TriggerStatus,   // implements psm.IStatusEnum
	*TriggerData,    // implements psm.IStateData
	*TriggerEvent,   // implements psm.IEvent
	TriggerPSMEvent, // implements psm.IInnerEvent
]

type TriggerPSMHookBaton = psm.HookBaton[
	*TriggerKeys,    // implements psm.IKeyset
	*TriggerState,   // implements psm.IState
	TriggerStatus,   // implements psm.IStatusEnum
	*TriggerData,    // implements psm.IStateData
	*TriggerEvent,   // implements psm.IEvent
	TriggerPSMEvent, // implements psm.IInnerEvent
]

type TriggerPSMFullBaton = psm.CallbackBaton[
	*TriggerKeys,    // implements psm.IKeyset
	*TriggerState,   // implements psm.IState
	TriggerStatus,   // implements psm.IStatusEnum
	*TriggerData,    // implements psm.IStateData
	*TriggerEvent,   // implements psm.IEvent
	TriggerPSMEvent, // implements psm.IInnerEvent
]

type TriggerPSMEventKey = string

const (
	TriggerPSMEventNil               TriggerPSMEventKey = "<nil>"
	TriggerPSMEventCreated           TriggerPSMEventKey = "created"
	TriggerPSMEventUpdated           TriggerPSMEventKey = "updated"
	TriggerPSMEventPaused            TriggerPSMEventKey = "paused"
	TriggerPSMEventActivated         TriggerPSMEventKey = "activated"
	TriggerPSMEventManuallyTriggered TriggerPSMEventKey = "manually_triggered"
	TriggerPSMEventTriggered         TriggerPSMEventKey = "triggered"
	TriggerPSMEventArchived          TriggerPSMEventKey = "archived"
)

// EXTEND TriggerKeys with the psm.IKeyset interface

// PSMIsSet is a helper for != nil, which does not work with generic parameters
func (msg *TriggerKeys) PSMIsSet() bool {
	return msg != nil
}

// PSMFullName returns the full name of state machine with package prefix
func (msg *TriggerKeys) PSMFullName() string {
	return "o5.trigger.v1.trigger"
}
func (msg *TriggerKeys) PSMKeyValues() (map[string]any, error) {
	keyset := map[string]any{
		"trigger_id": msg.TriggerId,
	}
	return keyset, nil
}

// EXTEND TriggerState with the psm.IState interface

// PSMIsSet is a helper for != nil, which does not work with generic parameters
func (msg *TriggerState) PSMIsSet() bool {
	return msg != nil
}

func (msg *TriggerState) PSMMetadata() *psm_j5pb.StateMetadata {
	if msg.Metadata == nil {
		msg.Metadata = &psm_j5pb.StateMetadata{}
	}
	return msg.Metadata
}

func (msg *TriggerState) PSMKeys() *TriggerKeys {
	return msg.Keys
}

func (msg *TriggerState) SetStatus(status TriggerStatus) {
	msg.Status = status
}

func (msg *TriggerState) SetPSMKeys(inner *TriggerKeys) {
	msg.Keys = inner
}

func (msg *TriggerState) PSMData() *TriggerData {
	if msg.Data == nil {
		msg.Data = &TriggerData{}
	}
	return msg.Data
}

// EXTEND TriggerData with the psm.IStateData interface

// PSMIsSet is a helper for != nil, which does not work with generic parameters
func (msg *TriggerData) PSMIsSet() bool {
	return msg != nil
}

// EXTEND TriggerEvent with the psm.IEvent interface

// PSMIsSet is a helper for != nil, which does not work with generic parameters
func (msg *TriggerEvent) PSMIsSet() bool {
	return msg != nil
}

func (msg *TriggerEvent) PSMMetadata() *psm_j5pb.EventMetadata {
	if msg.Metadata == nil {
		msg.Metadata = &psm_j5pb.EventMetadata{}
	}
	return msg.Metadata
}

func (msg *TriggerEvent) PSMKeys() *TriggerKeys {
	return msg.Keys
}

func (msg *TriggerEvent) SetPSMKeys(inner *TriggerKeys) {
	msg.Keys = inner
}

// PSMEventKey returns the TriggerPSMEventPSMEventKey for the event, implementing psm.IEvent
func (msg *TriggerEvent) PSMEventKey() TriggerPSMEventKey {
	tt := msg.UnwrapPSMEvent()
	if tt == nil {
		return TriggerPSMEventNil
	}
	return tt.PSMEventKey()
}

// UnwrapPSMEvent implements psm.IEvent, returning the inner event message
func (msg *TriggerEvent) UnwrapPSMEvent() TriggerPSMEvent {
	if msg == nil {
		return nil
	}
	if msg.Event == nil {
		return nil
	}
	switch v := msg.Event.Type.(type) {
	case *TriggerEventType_Created_:
		return v.Created
	case *TriggerEventType_Updated_:
		return v.Updated
	case *TriggerEventType_Paused_:
		return v.Paused
	case *TriggerEventType_Activated_:
		return v.Activated
	case *TriggerEventType_ManuallyTriggered_:
		return v.ManuallyTriggered
	case *TriggerEventType_Triggered_:
		return v.Triggered
	case *TriggerEventType_Archived_:
		return v.Archived
	default:
		return nil
	}
}

// SetPSMEvent sets the inner event message from a concrete type, implementing psm.IEvent
func (msg *TriggerEvent) SetPSMEvent(inner TriggerPSMEvent) error {
	if msg.Event == nil {
		msg.Event = &TriggerEventType{}
	}
	switch v := inner.(type) {
	case *TriggerEventType_Created:
		msg.Event.Type = &TriggerEventType_Created_{Created: v}
	case *TriggerEventType_Updated:
		msg.Event.Type = &TriggerEventType_Updated_{Updated: v}
	case *TriggerEventType_Paused:
		msg.Event.Type = &TriggerEventType_Paused_{Paused: v}
	case *TriggerEventType_Activated:
		msg.Event.Type = &TriggerEventType_Activated_{Activated: v}
	case *TriggerEventType_ManuallyTriggered:
		msg.Event.Type = &TriggerEventType_ManuallyTriggered_{ManuallyTriggered: v}
	case *TriggerEventType_Triggered:
		msg.Event.Type = &TriggerEventType_Triggered_{Triggered: v}
	case *TriggerEventType_Archived:
		msg.Event.Type = &TriggerEventType_Archived_{Archived: v}
	default:
		return fmt.Errorf("invalid type %T for TriggerEventType", v)
	}
	return nil
}

type TriggerPSMEvent interface {
	psm.IInnerEvent
	PSMEventKey() TriggerPSMEventKey
}

// EXTEND TriggerEventType_Created with the TriggerPSMEvent interface

// PSMIsSet is a helper for != nil, which does not work with generic parameters
func (msg *TriggerEventType_Created) PSMIsSet() bool {
	return msg != nil
}

func (*TriggerEventType_Created) PSMEventKey() TriggerPSMEventKey {
	return TriggerPSMEventCreated
}

// EXTEND TriggerEventType_Updated with the TriggerPSMEvent interface

// PSMIsSet is a helper for != nil, which does not work with generic parameters
func (msg *TriggerEventType_Updated) PSMIsSet() bool {
	return msg != nil
}

func (*TriggerEventType_Updated) PSMEventKey() TriggerPSMEventKey {
	return TriggerPSMEventUpdated
}

// EXTEND TriggerEventType_Paused with the TriggerPSMEvent interface

// PSMIsSet is a helper for != nil, which does not work with generic parameters
func (msg *TriggerEventType_Paused) PSMIsSet() bool {
	return msg != nil
}

func (*TriggerEventType_Paused) PSMEventKey() TriggerPSMEventKey {
	return TriggerPSMEventPaused
}

// EXTEND TriggerEventType_Activated with the TriggerPSMEvent interface

// PSMIsSet is a helper for != nil, which does not work with generic parameters
func (msg *TriggerEventType_Activated) PSMIsSet() bool {
	return msg != nil
}

func (*TriggerEventType_Activated) PSMEventKey() TriggerPSMEventKey {
	return TriggerPSMEventActivated
}

// EXTEND TriggerEventType_ManuallyTriggered with the TriggerPSMEvent interface

// PSMIsSet is a helper for != nil, which does not work with generic parameters
func (msg *TriggerEventType_ManuallyTriggered) PSMIsSet() bool {
	return msg != nil
}

func (*TriggerEventType_ManuallyTriggered) PSMEventKey() TriggerPSMEventKey {
	return TriggerPSMEventManuallyTriggered
}

// EXTEND TriggerEventType_Triggered with the TriggerPSMEvent interface

// PSMIsSet is a helper for != nil, which does not work with generic parameters
func (msg *TriggerEventType_Triggered) PSMIsSet() bool {
	return msg != nil
}

func (*TriggerEventType_Triggered) PSMEventKey() TriggerPSMEventKey {
	return TriggerPSMEventTriggered
}

// EXTEND TriggerEventType_Archived with the TriggerPSMEvent interface

// PSMIsSet is a helper for != nil, which does not work with generic parameters
func (msg *TriggerEventType_Archived) PSMIsSet() bool {
	return msg != nil
}

func (*TriggerEventType_Archived) PSMEventKey() TriggerPSMEventKey {
	return TriggerPSMEventArchived
}

func TriggerPSMBuilder() *psm.StateMachineConfig[
	*TriggerKeys,    // implements psm.IKeyset
	*TriggerState,   // implements psm.IState
	TriggerStatus,   // implements psm.IStatusEnum
	*TriggerData,    // implements psm.IStateData
	*TriggerEvent,   // implements psm.IEvent
	TriggerPSMEvent, // implements psm.IInnerEvent
] {
	return &psm.StateMachineConfig[
		*TriggerKeys,    // implements psm.IKeyset
		*TriggerState,   // implements psm.IState
		TriggerStatus,   // implements psm.IStatusEnum
		*TriggerData,    // implements psm.IStateData
		*TriggerEvent,   // implements psm.IEvent
		TriggerPSMEvent, // implements psm.IInnerEvent
	]{}
}

// TriggerPSMMutation runs at the start of a transition to merge the event information into the state data object. The state object is mutable in this context.
func TriggerPSMMutation[SE TriggerPSMEvent](cb func(*TriggerData, SE) error) psm.TransitionMutation[
	*TriggerKeys,    // implements psm.IKeyset
	*TriggerState,   // implements psm.IState
	TriggerStatus,   // implements psm.IStatusEnum
	*TriggerData,    // implements psm.IStateData
	*TriggerEvent,   // implements psm.IEvent
	TriggerPSMEvent, // implements psm.IInnerEvent
	SE,              // Specific event type for the transition
] {
	return psm.TransitionMutation[
		*TriggerKeys,    // implements psm.IKeyset
		*TriggerState,   // implements psm.IState
		TriggerStatus,   // implements psm.IStatusEnum
		*TriggerData,    // implements psm.IStateData
		*TriggerEvent,   // implements psm.IEvent
		TriggerPSMEvent, // implements psm.IInnerEvent
		SE,              // Specific event type for the transition
	](cb)
}

// TriggerPSMLogicHook runs after the mutation is complete. This hook can trigger side effects, including chained events, which are additional events processed by the state machine. Use this for Business Logic which determines the 'next step' in processing.
func TriggerPSMLogicHook[
	SE TriggerPSMEvent,
](
	cb func(
		context.Context,
		TriggerPSMHookBaton,
		*TriggerState,
		SE,
	) error) psm.TransitionHook[
	*TriggerKeys,    // implements psm.IKeyset
	*TriggerState,   // implements psm.IState
	TriggerStatus,   // implements psm.IStatusEnum
	*TriggerData,    // implements psm.IStateData
	*TriggerEvent,   // implements psm.IEvent
	TriggerPSMEvent, // implements psm.IInnerEvent
] {
	eventType := (*new(SE)).PSMEventKey()
	return psm.TransitionHook[
		*TriggerKeys,    // implements psm.IKeyset
		*TriggerState,   // implements psm.IState
		TriggerStatus,   // implements psm.IStatusEnum
		*TriggerData,    // implements psm.IStateData
		*TriggerEvent,   // implements psm.IEvent
		TriggerPSMEvent, // implements psm.IInnerEvent
	]{
		Callback: func(ctx context.Context, tx sqrlx.Transaction, baton TriggerPSMFullBaton, state *TriggerState, event *TriggerEvent) error {
			asType, ok := any(event.UnwrapPSMEvent()).(SE)
			if !ok {
				name := event.ProtoReflect().Descriptor().FullName()
				return fmt.Errorf("unexpected event type in transition: %s [IE] does not match [SE] (%T)", name, new(SE))
			}
			return cb(ctx, baton, state, asType)
		},
		EventType:   eventType,
		RunOnFollow: false,
	}
}

// TriggerPSMDataHook runs after the mutations, and can be used to update data in tables which are not controlled as the state machine, e.g. for pre-calculating fields for performance reasons. Use of this hook prevents (future) transaction optimizations, as the transaction state when the function is called must needs to match the processing state, but only for this single transition, unlike the GeneralEventDataHook.
func TriggerPSMDataHook[
	SE TriggerPSMEvent,
](
	cb func(
		context.Context,
		sqrlx.Transaction,
		*TriggerState,
		SE,
	) error) psm.TransitionHook[
	*TriggerKeys,    // implements psm.IKeyset
	*TriggerState,   // implements psm.IState
	TriggerStatus,   // implements psm.IStatusEnum
	*TriggerData,    // implements psm.IStateData
	*TriggerEvent,   // implements psm.IEvent
	TriggerPSMEvent, // implements psm.IInnerEvent
] {
	eventType := (*new(SE)).PSMEventKey()
	return psm.TransitionHook[
		*TriggerKeys,    // implements psm.IKeyset
		*TriggerState,   // implements psm.IState
		TriggerStatus,   // implements psm.IStatusEnum
		*TriggerData,    // implements psm.IStateData
		*TriggerEvent,   // implements psm.IEvent
		TriggerPSMEvent, // implements psm.IInnerEvent
	]{
		Callback: func(ctx context.Context, tx sqrlx.Transaction, baton TriggerPSMFullBaton, state *TriggerState, event *TriggerEvent) error {
			asType, ok := any(event.UnwrapPSMEvent()).(SE)
			if !ok {
				name := event.ProtoReflect().Descriptor().FullName()
				return fmt.Errorf("unexpected event type in transition: %s [IE] does not match [SE] (%T)", name, new(SE))
			}
			return cb(ctx, tx, state, asType)
		},
		EventType:   eventType,
		RunOnFollow: true,
	}
}

// TriggerPSMLinkHook runs after the mutation and logic hook, and can be used to link the state machine to other state machines in the same database transaction
func TriggerPSMLinkHook[
	SE TriggerPSMEvent,
	DK psm.IKeyset,
	DIE psm.IInnerEvent,
](
	linkDestination psm.LinkDestination[DK, DIE],
	cb func(
		context.Context,
		*TriggerState,
		SE,
		func(DK, DIE),
	) error) psm.TransitionHook[
	*TriggerKeys,    // implements psm.IKeyset
	*TriggerState,   // implements psm.IState
	TriggerStatus,   // implements psm.IStatusEnum
	*TriggerData,    // implements psm.IStateData
	*TriggerEvent,   // implements psm.IEvent
	TriggerPSMEvent, // implements psm.IInnerEvent
] {
	eventType := (*new(SE)).PSMEventKey()
	wrapped := func(ctx context.Context, tx sqrlx.Transaction, state *TriggerState, event SE, add func(DK, DIE)) error {
		return cb(ctx, state, event, add)
	}
	return psm.TransitionHook[
		*TriggerKeys,    // implements psm.IKeyset
		*TriggerState,   // implements psm.IState
		TriggerStatus,   // implements psm.IStatusEnum
		*TriggerData,    // implements psm.IStateData
		*TriggerEvent,   // implements psm.IEvent
		TriggerPSMEvent, // implements psm.IInnerEvent
	]{
		Callback: func(ctx context.Context, tx sqrlx.Transaction, baton TriggerPSMFullBaton, state *TriggerState, event *TriggerEvent) error {
			return psm.RunLinkHook(ctx, linkDestination, wrapped, tx, state, event)
		},
		EventType:   eventType,
		RunOnFollow: false,
	}
}

// TriggerPSMLinkDBHook like LinkHook, but has access to the current transaction for reads only (not enforced), use in place of controller logic to look up existing state.
func TriggerPSMLinkDBHook[
	SE TriggerPSMEvent,
	DK psm.IKeyset,
	DIE psm.IInnerEvent,
](
	linkDestination psm.LinkDestination[DK, DIE],
	cb func(
		context.Context,
		sqrlx.Transaction,
		*TriggerState,
		SE,
		func(DK, DIE),
	) error) psm.TransitionHook[
	*TriggerKeys,    // implements psm.IKeyset
	*TriggerState,   // implements psm.IState
	TriggerStatus,   // implements psm.IStatusEnum
	*TriggerData,    // implements psm.IStateData
	*TriggerEvent,   // implements psm.IEvent
	TriggerPSMEvent, // implements psm.IInnerEvent
] {
	eventType := (*new(SE)).PSMEventKey()
	return psm.TransitionHook[
		*TriggerKeys,    // implements psm.IKeyset
		*TriggerState,   // implements psm.IState
		TriggerStatus,   // implements psm.IStatusEnum
		*TriggerData,    // implements psm.IStateData
		*TriggerEvent,   // implements psm.IEvent
		TriggerPSMEvent, // implements psm.IInnerEvent
	]{
		Callback: func(ctx context.Context, tx sqrlx.Transaction, baton TriggerPSMFullBaton, state *TriggerState, event *TriggerEvent) error {
			return psm.RunLinkHook(ctx, linkDestination, cb, tx, state, event)
		},
		EventType:   eventType,
		RunOnFollow: false,
	}
}

// TriggerPSMGeneralLogicHook runs once per transition at the state-machine level regardless of which transition / event is being processed. It runs exactly once per transition, with the state object in the final state after the transition but prior to processing any further events. Chained events are added to the *end* of the event queue for the transaction, and side effects are published (as always) when the transaction is committed. The function MUST be pure, i.e. It MUST NOT produce any side-effects outside of the HookBaton, and MUST NOT modify the state.
func TriggerPSMGeneralLogicHook(
	cb func(
		context.Context,
		TriggerPSMHookBaton,
		*TriggerState,
		*TriggerEvent,
	) error) psm.GeneralEventHook[
	*TriggerKeys,    // implements psm.IKeyset
	*TriggerState,   // implements psm.IState
	TriggerStatus,   // implements psm.IStatusEnum
	*TriggerData,    // implements psm.IStateData
	*TriggerEvent,   // implements psm.IEvent
	TriggerPSMEvent, // implements psm.IInnerEvent
] {
	return psm.GeneralEventHook[
		*TriggerKeys,    // implements psm.IKeyset
		*TriggerState,   // implements psm.IState
		TriggerStatus,   // implements psm.IStatusEnum
		*TriggerData,    // implements psm.IStateData
		*TriggerEvent,   // implements psm.IEvent
		TriggerPSMEvent, // implements psm.IInnerEvent
	]{
		Callback: func(
			ctx context.Context,
			tx sqrlx.Transaction,
			baton TriggerPSMFullBaton,
			state *TriggerState,
			event *TriggerEvent,
		) error {
			return cb(ctx, baton, state, event)
		},
		RunOnFollow: false,
	}
}

// TriggerPSMGeneralStateDataHook runs at the state-machine level regardless of which transition / event is being processed. It runs at-least once before committing a database transaction after multiple transitions are complete. This hook has access only to the final state after the transitions and is used to update other tables based on the resulting state. It MUST be idempotent, it may be called after injecting externally-held state data.
func TriggerPSMGeneralStateDataHook(
	cb func(
		context.Context,
		sqrlx.Transaction,
		*TriggerState,
	) error) psm.GeneralStateHook[
	*TriggerKeys,    // implements psm.IKeyset
	*TriggerState,   // implements psm.IState
	TriggerStatus,   // implements psm.IStatusEnum
	*TriggerData,    // implements psm.IStateData
	*TriggerEvent,   // implements psm.IEvent
	TriggerPSMEvent, // implements psm.IInnerEvent
] {
	return psm.GeneralStateHook[
		*TriggerKeys,    // implements psm.IKeyset
		*TriggerState,   // implements psm.IState
		TriggerStatus,   // implements psm.IStatusEnum
		*TriggerData,    // implements psm.IStateData
		*TriggerEvent,   // implements psm.IEvent
		TriggerPSMEvent, // implements psm.IInnerEvent
	]{
		Callback: func(
			ctx context.Context,
			tx sqrlx.Transaction,
			baton TriggerPSMFullBaton,
			state *TriggerState,
		) error {
			return cb(ctx, tx, state)
		},
		RunOnFollow: true,
	}
}

// TriggerPSMGeneralEventDataHook runs after each transition at the state-machine level regardless of which transition / event is being processed. It runs exactly once per transition, before any other events are processed. The presence of this hook type prevents (future) transaction optimizations, so should be used sparingly.
func TriggerPSMGeneralEventDataHook(
	cb func(
		context.Context,
		sqrlx.Transaction,
		*TriggerState,
		*TriggerEvent,
	) error) psm.GeneralEventHook[
	*TriggerKeys,    // implements psm.IKeyset
	*TriggerState,   // implements psm.IState
	TriggerStatus,   // implements psm.IStatusEnum
	*TriggerData,    // implements psm.IStateData
	*TriggerEvent,   // implements psm.IEvent
	TriggerPSMEvent, // implements psm.IInnerEvent
] {
	return psm.GeneralEventHook[
		*TriggerKeys,    // implements psm.IKeyset
		*TriggerState,   // implements psm.IState
		TriggerStatus,   // implements psm.IStatusEnum
		*TriggerData,    // implements psm.IStateData
		*TriggerEvent,   // implements psm.IEvent
		TriggerPSMEvent, // implements psm.IInnerEvent
	]{
		Callback: func(
			ctx context.Context,
			tx sqrlx.Transaction,
			baton TriggerPSMFullBaton,
			state *TriggerState,
			event *TriggerEvent,
		) error {
			return cb(ctx, tx, state, event)
		},
		RunOnFollow: true,
	}
}

// TriggerPSMEventPublishHook  EventPublishHook runs for each transition, at least once before committing a database transaction after multiple transitions are complete. It should publish a derived version of the event using the publisher.
func TriggerPSMEventPublishHook(
	cb func(
		context.Context,
		psm.Publisher,
		*TriggerState,
		*TriggerEvent,
	) error) psm.GeneralEventHook[
	*TriggerKeys,    // implements psm.IKeyset
	*TriggerState,   // implements psm.IState
	TriggerStatus,   // implements psm.IStatusEnum
	*TriggerData,    // implements psm.IStateData
	*TriggerEvent,   // implements psm.IEvent
	TriggerPSMEvent, // implements psm.IInnerEvent
] {
	return psm.GeneralEventHook[
		*TriggerKeys,    // implements psm.IKeyset
		*TriggerState,   // implements psm.IState
		TriggerStatus,   // implements psm.IStatusEnum
		*TriggerData,    // implements psm.IStateData
		*TriggerEvent,   // implements psm.IEvent
		TriggerPSMEvent, // implements psm.IInnerEvent
	]{
		Callback: func(
			ctx context.Context,
			tx sqrlx.Transaction,
			baton TriggerPSMFullBaton,
			state *TriggerState,
			event *TriggerEvent,
		) error {
			return cb(ctx, baton, state, event)
		},
		RunOnFollow: false,
	}
}

// TriggerPSMUpsertPublishHook runs for each transition, at least once before committing a database transaction after multiple transitions are complete. It should publish a derived version of the event using the publisher.
func TriggerPSMUpsertPublishHook(
	cb func(
		context.Context,
		psm.Publisher,
		*TriggerState,
	) error) psm.GeneralStateHook[
	*TriggerKeys,    // implements psm.IKeyset
	*TriggerState,   // implements psm.IState
	TriggerStatus,   // implements psm.IStatusEnum
	*TriggerData,    // implements psm.IStateData
	*TriggerEvent,   // implements psm.IEvent
	TriggerPSMEvent, // implements psm.IInnerEvent
] {
	return psm.GeneralStateHook[
		*TriggerKeys,    // implements psm.IKeyset
		*TriggerState,   // implements psm.IState
		TriggerStatus,   // implements psm.IStatusEnum
		*TriggerData,    // implements psm.IStateData
		*TriggerEvent,   // implements psm.IEvent
		TriggerPSMEvent, // implements psm.IInnerEvent
	]{
		Callback: func(
			ctx context.Context,
			tx sqrlx.Transaction,
			baton TriggerPSMFullBaton,
			state *TriggerState,
		) error {
			return cb(ctx, baton, state)
		},
		RunOnFollow: false,
	}
}

func (event *TriggerEvent) EventPublishMetadata() *psm_j5pb.EventPublishMetadata {
	tenantKeys := make([]*psm_j5pb.EventTenant, 0)
	return &psm_j5pb.EventPublishMetadata{
		EventId:   event.Metadata.EventId,
		Sequence:  event.Metadata.Sequence,
		Timestamp: event.Metadata.Timestamp,
		Cause:     event.Metadata.Cause,
		Auth: &psm_j5pb.PublishAuth{
			TenantKeys: tenantKeys,
		},
	}
}
